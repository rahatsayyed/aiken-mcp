import { Stdlib } from "@/types";

export const stdlib: Stdlib = {
  "aiken/cbor": {
    f: [
      "diagnostic(self: Data) -> String",
      "deserialise(bytes: ByteArray) -> Option<Data>",
      "serialise(self: Data) -> ByteArray",
    ],
  },
  "aiken/interval": {
    d: "In a eUTxO-based blockchain like Cardano, the management of time can be\nfinicky.",
    t: [
      "Interval { lower_bound: IntervalBound, upper_bound: IntervalBound }",
      "IntervalBound { bound_type: IntervalBoundType, is_inclusive: Bool }",
      "IntervalBoundType = NegativeInfinity | Finite(Int) | PositiveInfinity",
    ],
    f: [
      "after(lower_bound: Int) -> Interval",
      "entirely_after(lower_bound: Int) -> Interval",
      "before(upper_bound: Int) -> Interval",
      "entirely_before(upper_bound: Int) -> Interval",
      "between(lower_bound: Int, upper_bound: Int) -> Interval",
      "entirely_between(lower_bound: Int, upper_bound: Int) -> Interval",
      "contains(self: Interval, elem: Int) -> Bool",
      "is_empty(self: Interval) -> Bool",
      "is_entirely_after(self: Interval, point: Int) -> Bool",
      "is_entirely_before(self: Interval, point: Int) -> Bool",
      "to_string(self: Interval) -> String",
      "hull(iv1: Interval, iv2: Interval) -> Interval",
      "includes(self: Interval, other: Interval) -> Bool",
      "intersection(iv1: Interval, iv2: Interval) -> Interval",
      "max(left: IntervalBound, right: IntervalBound) -> IntervalBound",
      "min(left: IntervalBound, right: IntervalBound) -> IntervalBound",
    ],
  },
  "aiken/collection": {
    t: ["Index = Int"],
  },
  "aiken/option": {
    d: "A type to capture optional results; useful for handling errors.",
    f: [
      "is_none(self: Option<a>) -> Bool",
      "is_some(self: Option<a>) -> Bool",
      "and_then(self: Option<a>, then: fn(a) -> Option<result>) -> Option<result>",
      "choice(self: List<Option<a>>) -> Option<a>",
      "flatten(opt: Option<Option<a>>) -> Option<a>",
      "map(self: Option<a>, with: fn(a) -> result) -> Option<result>",
      "map2( opt_a: Option<a>, opt_b: Option<b>, with: fn(a, b) -> result, ) -> Option<result>",
      "map3( opt_a: Option<a>, opt_b: Option<b>, opt_c: Option<c>, with: fn(a, b, c) -> result, ) -> Option<result>",
      "or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a>",
      "or_else(self: Option<a>, default: a) -> a",
    ],
  },
  "aiken/crypto": {
    t: [
      "DataHash = Hash<Blake2b_256, Data>",
      "Hash<alg, a> = ByteArray",
      "Script = ByteArray",
      "ScriptHash = Hash<Blake2b_224, Script>",
      "Signature = ByteArray",
      "VerificationKey = ByteArray",
      "VerificationKeyHash = Hash<Blake2b_224, VerificationKey>",
    ],
    f: [
      "blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a>",
      "blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a>",
      "keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a>",
      "sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a>",
      "sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a>",
      "verify_ecdsa_signature( key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool",
      "verify_ed25519_signature( key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool",
      "verify_schnorr_signature( key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool",
    ],
  },
  "aiken/math": {
    d: "This module contains some basic Math utilities. Standard arithmetic\noperations on integers are available through native operators:",
    f: [
      "abs(self: Int) -> Int",
      "clamp(self: Int, min: Int, max: Int) -> Int",
      "gcd(x: Int, y: Int) -> Int",
      "is_sqrt(self: Int, x: Int) -> Bool",
      "log(self: Int, base: Int) -> Int",
      "log2(x: Int) -> Int",
      "max(a: Int, b: Int) -> Int",
      "min(a: Int, b: Int) -> Int",
      "pow(self: Int, e: Int) -> Int",
      "pow2(e: Int) -> Int",
      "sqrt(self: Int) -> Option<Int>",
    ],
  },
  "aiken/crypto/int256": {
    t: ["State = bitwise.State<Bits256>"],
    f: [
      "from_bytearray_big_endian(bytes: ByteArray) -> State",
      "from_bytearray_little_endian(bytes: ByteArray) -> State",
      "from_int(int: Int) -> State",
      "scale(self: State, e: Int) -> State",
      "scale2(self: State, k: Int) -> State",
      "add(left: State, right: State) -> State",
      "add_bytes(self: State, bytes: ByteArray) -> State",
      "add_int(self: State, int: Int) -> State",
      "mul(left: State, right: State) -> State",
      "mul_bytes(self: State, bytes: ByteArray) -> State",
      "mul_int(self: State, int: Int) -> State",
      "neg(self: State) -> State",
      "sub(left: State, right: State) -> State",
      "sub_bytes(self: State, bytes: ByteArray) -> State",
      "sub_int(self: State, int: Int) -> State",
      "to_bytearray_big_endian(self: State) -> ByteArray",
      "to_bytearray_little_endian(self: State) -> ByteArray",
      "to_int(self: State) -> Int",
    ],
  },
  "aiken/crypto/int224": {
    t: ["State = bitwise.State<Bits224>"],
    f: [
      "from_bytearray_big_endian(bytes: ByteArray) -> State",
      "from_bytearray_little_endian(bytes: ByteArray) -> State",
      "from_int(int: Int) -> State",
      "scale(self: State, e: Int) -> State",
      "scale2(self: State, k: Int) -> State",
      "add(left: State, right: State) -> State",
      "add_bytes(self: State, bytes: ByteArray) -> State",
      "add_int(self: State, int: Int) -> State",
      "mul(left: State, right: State) -> State",
      "mul_bytes(self: State, bytes: ByteArray) -> State",
      "mul_int(self: State, int: Int) -> State",
      "neg(self: State) -> State",
      "sub(left: State, right: State) -> State",
      "sub_bytes(self: State, bytes: ByteArray) -> State",
      "sub_int(self: State, int: Int) -> State",
      "to_bytearray_big_endian(self: State) -> ByteArray",
      "to_bytearray_little_endian(self: State) -> ByteArray",
      "to_int(self: State) -> Int",
    ],
  },
  "aiken/crypto/bls12_381/scalar": {
    t: ["Scalar = ByteArray"],
    f: [
      "from_bytes(b: ByteArray) -> State<Scalar>",
      "from_bytes_little_endian(bytes: ByteArray) -> State<Scalar>",
      "from_int(n: Int) -> State<Scalar>",
      "scale(self: State<Scalar>, e: Int) -> State<Scalar>",
      "scale2(self: State<Scalar>, k: Int) -> State<Scalar>",
      "add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar>",
      "add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar>",
      "add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar>",
      "div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>>",
      "div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>>",
      "div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>>",
      "mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar>",
      "mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar>",
      "mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar>",
      "neg(intermediate: State<Scalar>) -> State<Scalar>",
      "recip(self: State<Scalar>) -> Option<State<Scalar>>",
      "sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar>",
      "sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar>",
      "sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar>",
      "to_int(s: State<Scalar>) -> Int",
      "to_bytes(s: State<Scalar>) -> ByteArray",
      "to_bytes_little_endian(s: State<Scalar>) -> ByteArray",
    ],
  },
  "aiken/crypto/bls12_381/g1": {
    d: "This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G1 group of the curve.",
    f: [
      "compress(point: G1Element) -> ByteArray",
      "decompress(bytes: ByteArray) -> G1Element",
      "equal(left: G1Element, right: G1Element) -> Bool",
      "add(left: G1Element, right: G1Element) -> G1Element",
      "sub(left: G1Element, right: G1Element) -> G1Element",
      "scale(point: G1Element, e: State<Scalar>) -> G1Element",
      "hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) -> G1Element",
    ],
  },
  "aiken/crypto/bls12_381/g2": {
    d: "This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G2 group of the curve.",
    f: [
      "compress(point: G2Element) -> ByteArray",
      "decompress(bytes: ByteArray) -> G2Element",
      "equal(left: G2Element, right: G2Element) -> Bool",
      "add(left: G2Element, right: G2Element) -> G2Element",
      "sub(left: G2Element, right: G2Element) -> G2Element",
      "scale(point: G2Element, e: State<Scalar>) -> G2Element",
      "hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) -> G2Element",
    ],
  },
  "aiken/collection/list": {
    t: ["Fold2<a, b, result> = fn(a, b) -> result"],
    f: [
      "push(self: List<a>, elem: a) -> List<a>",
      "range(from: Int, to: Int) -> List<Int>",
      "repeat(elem: a, n_times: Int) -> List<a>",
      "all(self: List<a>, predicate: fn(a) -> Bool) -> Bool",
      "any(self: List<a>, predicate: fn(a) -> Bool) -> Bool",
      "at(self: List<a>, index: Int) -> Option<a>",
      "count(self: List<a>, predicate: fn(a) -> Bool) -> Int",
      "find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a>",
      "find_map(self: List<a>, predicate: fn(a) -> Option<result>) -> Option<result>",
      "has(self: List<a>, elem: a) -> Bool",
      "head(self: List<a>) -> Option<a>",
      "is_empty(self: List<a>) -> Bool",
      "index_of(self: List<a>, elem: a) -> Option<Int>",
      "last(self: List<a>) -> Option<a>",
      "length(self: List<a>) -> Int",
      "delete(self: List<a>, elem: a) -> List<a>",
      "drop(self: List<a>, n: Int) -> List<a>",
      "drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a>",
      "filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a>",
      "filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b>",
      "init(self: List<a>) -> Option<List<a>>",
      "partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>)",
      "slice(self: List<a>, from: Int, to: Int) -> List<a>",
      "span(self: List<a>, n: Int) -> (List<a>, List<a>)",
      "tail(self: List<a>) -> Option<List<a>>",
      "take(self: List<a>, n: Int) -> List<a>",
      "take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a>",
      "unique(self: List<a>) -> List<a>",
      "flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b>",
      "for_each(self: List<a>, do: fn(a) -> Void) -> Void",
      "indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result>",
      "map(self: List<a>, with: fn(a) -> result) -> List<result>",
      "map2(self: List<a>, bs: List<b>, with: fn(a, b) -> result) -> List<result>",
      "map3( self: List<a>, bs: List<b>, cs: List<c>, with: fn(a, b, c) -> result, ) -> List<result>",
      "reverse(self: List<a>) -> List<a>",
      "sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a>",
      "unzip(self: List<(a, b)>) -> (List<a>, List<b>)",
      "concat(left: List<a>, right: List<a>) -> List<a>",
      "difference(self: List<a>, with: List<a>) -> List<a>",
      "zip(self: List<a>, bs: List<b>) -> List<(a, b)>",
      "foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b",
      "foldl2( self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>, ) -> result",
      "foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b",
      "foldr2( self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>, ) -> result",
      "indexed_foldr( self: List<a>, zero: result, with: fn(Int, a, result) -> result, ) -> result",
      "reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b",
    ],
  },
  "aiken/collection/pairs": {
    f: [
      "get_all(self: Pairs<key, value>, key: key) -> List<value>",
      "get_first(self: Pairs<key, value>, key: key) -> Option<value>",
      "get_last(self: Pairs<key, value>, key: key) -> Option<value>",
      "find_all(self: Pairs<key, value>, v: value) -> List<key>",
      "find_first(self: Pairs<key, value>, v: value) -> Option<key>",
      "find_last(self: Pairs<key, value>, v: value) -> Option<key>",
      "has_key(self: Pairs<key, value>, k: key) -> Bool",
      "keys(self: Pairs<key, value>) -> List<key>",
      "values(self: Pairs<key, value>) -> List<value>",
      "delete_all(self: Pairs<key, value>, key: key) -> Pairs<key, value>",
      "delete_first(self: Pairs<key, value>, key: key) -> Pairs<key, value>",
      "delete_last(self: Pairs<key, value>, key: key) -> Pairs<key, value>",
      "insert_by_ascending_key( self: Pairs<key, value>, key: key, value: value, compare: fn(key, key) -> Ordering, ) -> Pairs<key, value>",
      "insert_with_by_ascending_key( self: Pairs<key, value>, key: key, value: value, compare: fn(key, key) -> Ordering, with: fn(value, value) -> value, ) -> Pairs<key, value>",
      "map( self: Pairs<key, value>, with: fn(key, value) -> result, ) -> Pairs<key, result>",
      "repsert_by_ascending_key( self: Pairs<key, value>, key: key, value: value, compare: fn(key, key) -> Ordering, ) -> Pairs<key, value>",
      "foldl( self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result, ) -> result",
      "foldr( self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result, ) -> result",
    ],
  },
  "aiken/collection/dict": {
    d: "A module for working with bytearray dictionaries.",
    f: [
      "from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value>",
      "from_ascending_pairs_with( xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool, ) -> Dict<key, value>",
      "from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value>",
      "find(self: Dict<key, value>, value: value) -> Option<ByteArray>",
      "get(self: Dict<key, value>, key: ByteArray) -> Option<value>",
      "get_or_else( self: Dict<key, value>, key: ByteArray, or_else: fn() -> value, ) -> value",
      "has_key(self: Dict<key, value>, key: ByteArray) -> Bool",
      "is_empty(self: Dict<key, value>) -> Bool",
      "keys(self: Dict<key, value>) -> List<ByteArray>",
      "size(self: Dict<key, value>) -> Int",
      "values(self: Dict<key, value>) -> List<value>",
      "delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value>",
      "filter( self: Dict<key, value>, with: fn(ByteArray, value) -> Bool, ) -> Dict<key, value>",
      "insert(self: Dict<key, value>, key: ByteArray, value: value) -> Dict<key, value>",
      "insert_with( self: Dict<key, value>, key: ByteArray, value: value, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value>",
      "map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b>",
      "pop(self: Dict<key, value>, key: ByteArray) -> (Option<value>, Dict<key, value>)",
      "union(left: Dict<key, value>, right: Dict<key, value>) -> Dict<key, value>",
      "union_with( left: Dict<key, value>, right: Dict<key, value>, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value>",
      "foldl( self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result, ) -> result",
      "foldr( self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result, ) -> result",
      "to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value>",
    ],
},
  "aiken/primitive/int": {
    f: [
      "compare(left: Int, right: Int) -> Ordering",
      "from_bytearray_big_endian(self: ByteArray) -> Int",
      "from_bytearray_little_endian(self: ByteArray) -> Int",
      "from_utf8(bytes: ByteArray) -> Option<Int>",
      "to_string(n: Int) -> String",
    ],
  },
  "aiken/primitive/string": {
    f: [
      "from_bytearray(bytes: ByteArray) -> String",
      "from_int(n: Int) -> String",
      "concat(left: String, right: String) -> String",
      "join(list: List<String>, delimiter: String) -> String",
      "to_bytearray(self: String) -> ByteArray",
    ],
  },
  "aiken/primitive/bytearray": {
    t: ["Byte = Int"],
    f: [
      "from_int_big_endian(self: Int, size: Int) -> ByteArray",
      "from_int_little_endian(self: Int, size: Int) -> ByteArray",
      "from_string(str: String) -> ByteArray",
      "push(self: ByteArray, byte: Byte) -> ByteArray",
      "at(self: ByteArray, index: Int) -> Byte",
      "index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)>",
      "is_empty(self: ByteArray) -> Bool",
      "length(self: ByteArray) -> Int",
      "test_bit(self: ByteArray, ix: Int) -> Bool",
      "drop(self: ByteArray, n: Int) -> ByteArray",
      "slice(self: ByteArray, start: Int, end: Int) -> ByteArray",
      "take(self: ByteArray, n: Int) -> ByteArray",
      "concat(left: ByteArray, right: ByteArray) -> ByteArray",
      "compare(left: ByteArray, right: ByteArray) -> Ordering",
      "foldl(self: ByteArray, zero: result, with: fn(Int, result) -> result) -> result",
      "foldr(self: ByteArray, zero: result, with: fn(Int, result) -> result) -> result",
      "reduce(self: ByteArray, zero: result, with: fn(result, Int) -> result) -> result",
      "to_int_big_endian(self: ByteArray) -> Int",
      "to_int_little_endian(self: ByteArray) -> Int",
      "to_string(self: ByteArray) -> String",
      "to_hex(self: ByteArray) -> String",
      "starts_with(self: ByteArray, prefix: ByteArray) -> Bool",
      "and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray",
      "or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray",
      "xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray",
    ],
  },
  "aiken/math/rational": {
    d: "This module implements operations between rational numbers.",
    f: [
      "from_int(numerator: Int) -> Rational",
      "new(numerator: Int, denominator: Int) -> Option<Rational>",
      "denominator(self: Rational) -> Int",
      "numerator(self: Rational) -> Int",
      "abs(self: Rational) -> Rational",
      "negate(a: Rational) -> Rational",
      "reciprocal(self: Rational) -> Option<Rational>",
      "reduce(self: Rational) -> Rational",
      "add(left: Rational, right: Rational) -> Rational",
      "div(left: Rational, right: Rational) -> Option<Rational>",
      "mul(left: Rational, right: Rational) -> Rational",
      "sub(left: Rational, right: Rational) -> Rational",
      "compare(left: Rational, right: Rational) -> Ordering",
      "compare_with( left: Rational, with: fn(Int, Int) -> Bool, right: Rational, ) -> Bool",
      "arithmetic_mean(self: List<Rational>) -> Option<Rational>",
      "geometric_mean(left: Rational, right: Rational) -> Option<Rational>",
      "ceil(self: Rational) -> Int",
      "floor(self: Rational) -> Int",
      "pow(x: Rational, y: Int) -> Option<Rational>",
      "proper_fraction(self: Rational) -> (Int, Rational)",
      "round(self: Rational) -> Int",
      "round_even(self: Rational) -> Int",
      "truncate(self: Rational) -> Int",
    ],
  },
  "cardano/assets": {
    t: [
      "AssetName = ByteArray",
      "Lovelace = Int",
      "PolicyId = Hash<Blake2b_224, Script>",
    ],
    f: [
      "from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int) -> Value",
      "from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value",
      "from_lovelace(quantity: Int) -> Value",
      "has_any_nft(self: Value, policy: PolicyId) -> Bool",
      "has_any_nft_strict(self: Value, policy: PolicyId) -> Bool",
      "has_nft(self: Value, policy: PolicyId, asset_name: AssetName) -> Bool",
      "has_nft_strict(self: Value, policy: PolicyId, asset_name: AssetName) -> Bool",
      "is_zero(self: Value) -> Bool",
      "match( left: Value, right: Data, assert_lovelace: fn(Lovelace, Lovelace) -> Bool, ) -> Bool",
      "lovelace_of(self: Value) -> Int",
      "policies(self: Value) -> List<PolicyId>",
      "quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName) -> Int",
      "tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int>",
      "add( self: Value, policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value",
      "merge(left: Value, right: Value) -> Value",
      "negate(self: Value) -> Value",
      "restricted_to(self: Value, mask: List<PolicyId>) -> Value",
      "without_lovelace(self: Value) -> Value",
      "flatten(self: Value) -> List<(PolicyId, AssetName, Int)>",
      "flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result>",
      "reduce( self: Value, start: result, with: fn(PolicyId, AssetName, Int, result) -> result, ) -> result",
      "to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>>",
    ],
  },
  "cardano/governance": {
    t: [
      "Constitution { guardrails: Option<ScriptHash> }",
      "GovernanceAction = ProtocolParameters { ancestor: Option<GovernanceActionId>, new_parameters: ProtocolParametersUpdate, guardrails: Option<ScriptHash>, } | HardFork { ancestor: Option<GovernanceActionId>, new_version: ProtocolVersion } | TreasuryWithdrawal { beneficiaries: Pairs<Credential, Lovelace>, guardrails: Option<ScriptHash>, } | NoConfidence { ancestor: Option<GovernanceActionId> } | ConstitutionalCommittee { ancestor: Option<GovernanceActionId>, evicted_members: List<Credential>, added_members: Pairs<Credential, Mandate>, quorum: Rational, } | NewConstitution { ancestor: Option<GovernanceActionId>, constitution: Constitution, } | NicePoll",
      "GovernanceActionId { transaction: TransactionId, proposal_procedure: Index }",
      "Mandate = Int",
      "ProposalProcedure { deposit: Lovelace, return_address: Credential, governance_action: GovernanceAction, }",
      "ProtocolVersion { major: Int, minor: Int }",
      "TransactionId = Hash<Blake2b_256, ByteArray>",
      "Vote = No | Yes | Abstain",
      "Voter = ConstitutionalCommitteeMember(Credential) | DelegateRepresentative(Credential) | StakePool(VerificationKeyHash)",
    ],
  },
  "cardano/certificate": {
    t: [
      "Certificate = RegisterCredential { credential: Credential, deposit: Never } | UnregisterCredential { credential: Credential, refund: Never } | DelegateCredential { credential: Credential, delegate: Delegate } | RegisterAndDelegateCredential { credential: Credential, delegate: Delegate, deposit: Lovelace, } | RegisterDelegateRepresentative { delegate_representative: Credential, deposit: Lovelace, } | UpdateDelegateRepresentative { delegate_representative: Credential } | UnregisterDelegateRepresentative { delegate_representative: Credential, refund: Lovelace, } | RegisterStakePool { stake_pool: StakePoolId, vrf: VerificationKeyHash } | RetireStakePool { stake_pool: StakePoolId, at_epoch: Int } | AuthorizeConstitutionalCommitteeProxy { constitutional_committee_member: Credential, proxy: Credential, } | RetireFromConstitutionalCommittee { constitutional_committee_member: Credential, }",
      "Delegate = DelegateBlockProduction { stake_pool: StakePoolId } | DelegateVote { delegate_representative: DelegateRepresentative } | DelegateBoth { stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, }",
      "DelegateRepresentative = Registered(Credential) | AlwaysAbstain | AlwaysNoConfidence",
      "StakePoolId = Hash<Blake2b_224, VerificationKey>",
    ],
  },
  "cardano/address": {
    t: [
      "Address { payment_credential: PaymentCredential, stake_credential: Option<StakeCredential>, }",
      "Credential = VerificationKey(VerificationKeyHash) | Script(ScriptHash)",
      "PaymentCredential = Credential",
      "Referenced<a> = Inline(a) | Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }",
      "StakeCredential = Referenced<Credential>",
    ],
    f: [
      "from_script(script: Hash<Blake2b_224, Script>) -> Address",
      "from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address",
      "with_delegation_key( self: Address, vk: Hash<Blake2b_224, VerificationKey>, ) -> Address",
      "with_delegation_script( self: Address, script: Hash<Blake2b_224, Script>, ) -> Address",
    ],
  },
  "cardano/script_context": {
    t: [
      "ScriptContext { transaction: Transaction, redeemer: Redeemer, info: ScriptInfo }",
      "ScriptInfo = Minting(PolicyId) | Spending { output: OutputReference, datum: Option<Data> } | Withdrawing(Credential) | Publishing { at: Index, certificate: Certificate } | Voting(Voter) | Proposing { at: Index, proposal_procedure: ProposalProcedure }",
    ],
  },
  "cardano/transaction": {
    t: [
      "Datum = NoDatum | DatumHash(DataHash) | InlineDatum(Data)",
      "Input { output_reference: OutputReference, output: Output }",
      "Output { address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, }",
      "OutputReference { transaction_id: Hash<Blake2b_256, Transaction>, output_index: Int, }",
      "Redeemer = Data",
      "ScriptPurpose = Mint(PolicyId) | Spend(OutputReference) | Withdraw(Credential) | Publish { at: Index, certificate: Certificate } | Vote(Voter) | Propose { at: Index, proposal_procedure: ProposalProcedure }",
      "Transaction { inputs: List<Input>, reference_inputs: List<Input>, outputs: List<Output>, fee: Lovelace, mint: Value, certificates: List<Certificate>, withdrawals: Pairs<Credential, Lovelace>, validity_range: ValidityRange, extra_signatories: List<VerificationKeyHash>, redeemers: Pairs<ScriptPurpose, Redeemer>, datums: Dict<DataHash, Data>, id: TransactionId, votes: Pairs<Voter, Pairs<GovernanceActionId, Vote>>, proposal_procedures: List<ProposalProcedure>, current_treasury_amount: Option<Lovelace>, treasury_donation: Option<Lovelace>, }",
      "TransactionId = Hash<Blake2b_256, Transaction>",
      "ValidityRange = Interval",
    ],
    f: [
      "find_input( inputs: List<Input>, output_reference: OutputReference, ) -> Option<Input>",
      "resolve_input(inputs: List<Input>, output_reference: OutputReference) -> Output",
      "find_datum( outputs: List<Output>, datums: Dict<DataHash, Data>, datum_hash: DataHash, ) -> Option<Data>",
      "find_script_outputs( outputs: List<Output>, script_hash: ScriptHash, ) -> List<Output>",
    ],
  },
  "cardano/transaction/script_purpose": {
    f: ["compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering"],
  },
  "cardano/transaction/output_reference": {
    f: ["compare(left: OutputReference, right: OutputReference) -> Ordering"],
  },
  "cardano/address/credential": {
    f: ["compare(left: Credential, right: Credential) -> Ordering"],
  },
  "cardano/governance/voter": {
    f: ["compare(left: Voter, right: Voter) -> Ordering"],
  },
  "cardano/governance/protocol_parameters": {
    t: [
      "ConstitutionalCommitteeThresholds { default: Rational, under_no_confidence: Rational, }",
      "DelegateRepresentativeVotingThresholds { motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, constitution: Rational, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Void, Rational, Rational, Rational, Rational, >, treasury_withdrawal: Rational, }",
      "ExecutionUnits { memory: Int, cpu: Int }",
      "ProtocolParametersThresholds<security, network, economic, technical, governance> = ProtocolParametersThresholds { security_group: security, network_group: network, economic_group: economic, technical_group: technical, governance_group: governance, }",
      "ScriptExecutionPrices { memory: Rational, cpu: Rational }",
      "StakePoolOperatorVotingThresholds { motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Rational, Void, Void, Void, Void, >, }",
    ],
    f: [
      "min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int>",
      "min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int>",
      "max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int>",
      "max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int>",
      "max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int>",
      "stake_credential_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace>",
      "stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace>",
      "stake_pool_retirement_horizon(self: ProtocolParametersUpdate) -> Option<Int>",
      "desired_number_of_stake_pools(self: ProtocolParametersUpdate) -> Option<Int>",
      "stake_pool_pledge_influence(self: ProtocolParametersUpdate) -> Option<Rational>",
      "monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational>",
      "treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational>",
      "min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace>",
      "min_utxo_deposit_coefficient(self: ProtocolParametersUpdate) -> Option<Int>",
      "cost_models(self: ProtocolParametersUpdate) -> Option<Data>",
      "script_execution_prices( self: ProtocolParametersUpdate, ) -> Option<ScriptExecutionPrices>",
      "max_transaction_execution_units( self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits>",
      "max_block_execution_units( self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits>",
      "max_value_size(self: ProtocolParametersUpdate) -> Option<Int>",
      "collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int>",
      "max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int>",
      "stake_pool_operator_voting_thresholds( self: ProtocolParametersUpdate, ) -> Option<StakePoolOperatorVotingThresholds>",
      "delegate_representative_voting_thresholds( self: ProtocolParametersUpdate, ) -> Option<DelegateRepresentativeVotingThresholds>",
      "min_constitutional_committee_size(self: ProtocolParametersUpdate) -> Option<Int>",
      "max_constitutional_committee_mandate( self: ProtocolParametersUpdate, ) -> Option<Int>",
      "governance_proposal_lifetime(self: ProtocolParametersUpdate) -> Option<Int>",
      "governance_proposal_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace>",
      "delegate_representative_deposit( self: ProtocolParametersUpdate, ) -> Option<Lovelace>",
      "delegate_representative_max_idle_time( self: ProtocolParametersUpdate, ) -> Option<Int>",
      "reference_scripts_tier_fee_initial_factor( self: ProtocolParametersUpdate, ) -> Option<Rational>",
    ],
  },
  "cardano/assets/strategy": {
    t: [
      "DiscardResult<result> = fn() -> List<result>",
      "FlattenStrategy<result> = fn( Hash<Blake2b_224, Script>, ByteArray, Int, KeepResult<result>, DiscardResult<result>, ) -> List<result>",
      "KeepResult<result> = fn(result) -> List<result>",
    ],
    f: [
      "triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)>",
    ],
  },
};
